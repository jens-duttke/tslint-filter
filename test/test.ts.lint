import SomeModule from './some-module';
~ [Error in 'tslint/lib/rules/doesNotExistRule': Cannot find module 'tslint/lib/rules/doesNotExistRule'. Rule is disabled for this file]
~ [No filter configuration given for rule '___no-import-side-effect']
import AnotherModule from './some-module';
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ [Misnamed import. Import should be named 'someModule' but found 'AnotherModule' for './some-module']
       ~~~~~~~~~~~~~ [Expected import 'AnotherModule' of module './some-module' to match the default export 'someModule'.]

interface I18N {}

interface IInterface {}
          ~~~~~~~~~~ [Interface name "IInterface" must not have an "I" prefix]

// tslint:disable-next-line:interface-name
interface ISomething {}

class Test {
	private readonly a;

	helloWorld (a, b, c) {
	~~~~~~~~~~ [The class method 'helloWorld' must be marked either 'private', 'public', or 'protected']

		let a: boolean;

		const s1: string[] = b || [];
		const s2: string[] = b && [];
		                          ~~ [This type is not allowed in the operand for the '&&' operator because it is always truthy. It may be null/undefined, but neither 'allow-null-union' nor 'allow-undefined-union' is set. Allowed types are boolean, enum, or boolean-or-undefined.]

		if (SomeModule) {
		~~ [Use a conditional expression instead of assigning to 'a' in multiple places. (save about 36 characters, conditional expression size would be about 29 characters)]
			a = true;
		}
		else {
			a = false;
		}

		let longText;
		    ~~~~~~~~ [expected variable-declaration: 'longText' to have a typedef]

		if (!AnotherModule) {
			longText = 'Some long text to get an expression which is longer than 120 characters, so that it doesn\'t fit into one line.';
		}
		else {
			longText = 'This expresson should not be converted into an conditional expression one-liner.';
		}
	}

	render (): void {}
}
